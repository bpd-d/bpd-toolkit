{"version":3,"sources":["webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/universalModuleDefinition","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/bootstrap","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/define property getters","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/hasOwnProperty shorthand","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/make namespace object","webpack://bpdToolkit.[name].bpdToolkit.[name]/./src/queue.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Queue","adapter","options","this","_lock","_items","_adapter","_comparer","undefined","_onError","_errorCount","_options","cleanQueueOnError","errorLimit","item","push","flush","then","index","findIndex","_item","compare","splice","callback","item1","item2","is","items","getItemsForFlush","length","onFlush","e","callError","type","result","shift","error"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,aAAc,GAAIH,GACC,iBAAZC,QACdA,QAAoB,WAAID,KAExBD,EAAiB,WAAIA,EAAiB,YAAK,GAAIA,EAAiB,WAAS,MAAIA,EAAiB,WAAS,OAAK,GAAIA,EAAiB,WAAS,MAAc,WAAIA,EAAiB,WAAS,MAAc,YAAK,GAAIA,EAAiB,WAAS,MAAc,WAAS,MAAIC,KARpQ,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1B,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3E,EAAwB,CAACM,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClF,EAAyBd,IACH,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,M,2UCsBhD,MAAMC,EAST,YAAYC,EAA2BC,GACnCC,KAAKC,OAAQ,EACbD,KAAKE,OAAS,GACdF,KAAKG,SAAWL,EAChBE,KAAKI,eAAYC,EACjBL,KAAKM,cAAWD,EAChBL,KAAKO,YAAc,EACnBP,KAAKQ,SAAW,CACZC,mBAAmB,EACnBC,WAAY,IAGZX,IACAC,KAAKQ,SAAW,OAAH,wBACNR,KAAKQ,UACLT,IASf,IAAIY,GACAX,KAAKE,OAAOU,KAAKD,GACbX,KAAKC,QAITD,KAAKC,OAAQ,EACbD,KAAKa,QAAQC,MAAK,KACdd,KAAKC,OAAQ,MAQrB,OAAOU,GACH,MAAMI,EAAQf,KAAKE,OAAOc,WAAUC,GAASjB,KAAKkB,QAAQD,EAAON,KACjE,KAAII,EAAQ,GAGZ,OAAOf,KAAKE,OAAOiB,OAAOJ,EAAO,GAAG,GAMxC,WACI,OAAOf,KAAKC,MAQhB,mBAAmBmB,GACfpB,KAAKI,UAAYgB,EAOrB,QAAQA,GACJpB,KAAKM,SAAWc,EAGZ,QAAQC,EAAUC,GACtB,OAAItB,KAAKI,UACEJ,KAAKI,UAAUiB,EAAOC,GAE1BrC,OAAOsC,GAAGF,EAAOC,GAGd,Q,yCACV,MAAME,EAAQxB,KAAKyB,mBACnB,GAAqB,IAAjBD,EAAME,OACN,OAAO,EAEX,UACU1B,KAAKG,SAASwB,QAAQH,GAC5BxB,KAAKO,YAAc,EACrB,MAAOqB,GACL5B,KAAKO,aAAe,EACpBP,KAAK6B,UAAUD,EAAGJ,GAClBxB,KAAKS,oBAGT,OAAOT,KAAKa,WAGR,oBACAb,KAAKQ,SAASC,mBAAqBT,KAAKQ,SAASE,YAAcV,KAAKO,aAAeP,KAAKQ,SAASE,aACjGV,KAAKE,OAAS,GACdF,KAAKO,YAAc,EACnBP,KAAK6B,UAAU,kCAAoC7B,KAAKQ,SAASE,WAAY,KAI7E,mBACJ,GAA2B,UAAvBV,KAAKG,SAAS2B,KAAkB,CAChC,IAAIC,EAAS,IAAI/B,KAAKE,QAEtB,OADAF,KAAKE,OAAS,GACP6B,EAEX,MAAMpB,EAAOX,KAAKE,OAAO8B,QACzB,OAAIrB,EACO,CAACA,GAEL,GAGH,UAAUsB,EAAgBT,GAC1BxB,KAAKM,UACLN,KAAKM,SAAS2B,EAAOjC,KAAKO,YAAaiB,I","file":"bpdToolkit.queue.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpdToolkit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpdToolkit\"] = factory();\n\telse\n\t\troot[\"bpdToolkit\"] = root[\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"queue\"] = root[\"bpdToolkit\"][\"queue\"] || {}, root[\"bpdToolkit\"][\"queue\"][\"bpdToolkit\"] = root[\"bpdToolkit\"][\"queue\"][\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"queue\"][\"bpdToolkit\"][\"queue\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export type QueueAdapterType = 'batch' | 'single';\r\n\r\nexport interface IQueueAdapter<T> {\r\n    type?: QueueAdapterType;\r\n    onFlush(items: T[]): Promise<boolean>;\r\n}\r\n\r\nexport interface QueueCompareCallback<T> {\r\n    (item1: T, item2: T): boolean;\r\n}\r\n\r\nexport interface QueueErrorCallback<T> {\r\n    (e: unknown, counter: number, items?: T[]): void;\r\n}\r\n\r\nexport interface QueueOptions {\r\n    cleanQueueOnError?: boolean;\r\n    errorLimit?: number;\r\n}\r\n\r\n/**\r\n * Provides basic implementation of queue. \r\n * It perform tasks as single - one by one or in batches - gets all queued tasks at the time.\r\n * Allows to remove task if it wasn't performed yet\r\n * \r\n * Queue gives only a basic logic - task execution is delegated to an adapter \r\n */\r\nexport class Queue<T> {\r\n    private _items: T[];\r\n    private _lock: boolean;\r\n    private _adapter: IQueueAdapter<T>;\r\n    private _onError?: QueueErrorCallback<T>;\r\n    private _comparer?: QueueCompareCallback<T>;\r\n    private _options: QueueOptions;\r\n    private _errorCount: number;\r\n\r\n    constructor(adapter: IQueueAdapter<T>, options?: QueueOptions) {\r\n        this._lock = false;\r\n        this._items = [];\r\n        this._adapter = adapter;\r\n        this._comparer = undefined;\r\n        this._onError = undefined;\r\n        this._errorCount = 0;\r\n        this._options = {\r\n            cleanQueueOnError: false,\r\n            errorLimit: 10\r\n        }\r\n\r\n        if (options) {\r\n            this._options = {\r\n                ...this._options,\r\n                ...options\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add item to a queue - it invokes flush right away\r\n     * @param item \r\n     */\r\n    add(item: T): void {\r\n        this._items.push(item);\r\n        if (this._lock) {\r\n            return;\r\n        }\r\n\r\n        this._lock = true;\r\n        this.flush().then(() => {\r\n            this._lock = false;\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Deletes item from task list \r\n     * @param item \r\n     */\r\n    delete(item: T): T | undefined {\r\n        const index = this._items.findIndex(_item => this.compare(_item, item));\r\n        if (index < 0) {\r\n            return undefined;\r\n        }\r\n        return this._items.splice(index, 1)[0];\r\n    }\r\n\r\n    /**\r\n     * Indicates whether queue is locked\r\n     */\r\n    isLocked(): boolean {\r\n        return this._lock;\r\n    }\r\n\r\n    /**\r\n     * Sets custom compare callback for cases where Object.is doesn't work\r\n     * Used for delete\r\n     * @param callback \r\n     */\r\n    setCompareCallback(callback: QueueCompareCallback<T>) {\r\n        this._comparer = callback;\r\n    }\r\n\r\n    /**\r\n     * Sets callback to catch errors occured during flush execution\r\n     * @param callback \r\n     */\r\n    onError(callback: QueueErrorCallback<T>) {\r\n        this._onError = callback;\r\n    }\r\n\r\n    private compare(item1: T, item2: T): boolean {\r\n        if (this._comparer) {\r\n            return this._comparer(item1, item2)\r\n        }\r\n        return Object.is(item1, item2);\r\n    }\r\n\r\n    private async flush(): Promise<boolean> {\r\n        const items = this.getItemsForFlush();\r\n        if (items.length === 0) {\r\n            return true;\r\n        }\r\n        try {\r\n            await this._adapter.onFlush(items);\r\n            this._errorCount = 0;\r\n        } catch (e) {\r\n            this._errorCount += 1;\r\n            this.callError(e, items);\r\n            this.cleanQueueOnError();\r\n        }\r\n\r\n        return this.flush();\r\n    }\r\n\r\n    private cleanQueueOnError() {\r\n        if (this._options.cleanQueueOnError && this._options.errorLimit && this._errorCount >= this._options.errorLimit) {\r\n            this._items = [];\r\n            this._errorCount = 0;\r\n            this.callError(\"Errors limit has been reached: \" + this._options.errorLimit, [])\r\n        }\r\n    }\r\n\r\n    private getItemsForFlush(): T[] {\r\n        if (this._adapter.type === 'batch') {\r\n            let result = [...this._items];\r\n            this._items = []\r\n            return result;\r\n        }\r\n        const item = this._items.shift();\r\n        if (item) {\r\n            return [item];\r\n        }\r\n        return [];\r\n    }\r\n\r\n    private callError(error: unknown, items?: T[]) {\r\n        if (this._onError) {\r\n            this._onError(error, this._errorCount, items)\r\n        }\r\n    }\r\n}"],"sourceRoot":""}