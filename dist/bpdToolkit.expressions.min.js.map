{"version":3,"sources":["webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/universalModuleDefinition","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/bootstrap","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/define property getters","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/hasOwnProperty shorthand","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/make namespace object","webpack://bpdToolkit.[name].bpdToolkit.[name]/./src/expressions.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","createOccurenceExpression","expression","min","max","all","group","notOneOf","oneOf","createOccurencePattern","range","matches","pattern","result","origin","input","time","t1","performance","now","matchResult","match","e","error","expressions","join","or","positiveLookahead","negativeLookahead","atLeastOne","noneOrMore","noneOrOne","capitalLetters","lowerLetters","digit","notDigit","whitespace","notWhitespace","word","notWord","any","specialCharacters","ValidationPattern","init","this","_list","push","expr","check","count","characters","specialChars","flags","RegExp","toString"],"mappings":"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","file":"bpdToolkit.expressions.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpdToolkit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpdToolkit\"] = factory();\n\telse\n\t\troot[\"bpdToolkit\"] = root[\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"expressions\"] = root[\"bpdToolkit\"][\"expressions\"] || {}, root[\"bpdToolkit\"][\"expressions\"][\"bpdToolkit\"] = root[\"bpdToolkit\"][\"expressions\"][\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"expressions\"][\"bpdToolkit\"][\"expressions\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export interface IValidationPattern {\r\n\texpr(...expressions: string[]): IValidationPattern;\r\n\tcheck(expression: string): IValidationPattern;\r\n\tofLength(min: number, max?: number): IValidationPattern;\r\n\twithCapital(count?: number): IValidationPattern;\r\n\twithLower(count?: number): IValidationPattern;\r\n\twithWhitespace(count?: number): IValidationPattern;\r\n\twithAnyOf(characters?: string): IValidationPattern;\r\n\twithNoneOf(characters: string): IValidationPattern;\r\n\twithDigits(count?: number): IValidationPattern;\r\n\tnoWhitespace(): IValidationPattern;\r\n\tdigitsOnly(): IValidationPattern;\r\n\twordOnly(): IValidationPattern;\r\n\tnoDigits(): IValidationPattern;\r\n}\r\n\r\nexport interface IExpressionPattern {\r\n\ttoExpression(flags?: string): RegExp;\r\n}\r\n\r\ninterface IMatchResult {\r\n\tresult: boolean;\r\n\tinput: string;\r\n\terror?: Error | string;\r\n\torigin: RegExpMatchArray | null;\r\n\ttime: number;\r\n\tpattern: RegExp | string | null;\r\n}\r\n\r\n/**\r\n * Creates expression like ([^expr]*[exp][^exp]*)\r\n * @param expression\r\n * @returns new expression following pattern\r\n */\r\nfunction createOccurencePattern(expression: string) {\r\n\treturn group(\r\n\t\tnotOneOf(expression),\r\n\t\t\"*\",\r\n\t\toneOf(expression),\r\n\t\tnotOneOf(expression),\r\n\t\t\"*\"\r\n\t);\r\n}\r\n\r\n/**\r\n * Creates expression like ^([^expr]*[expr][^expr]*){min, max}$\r\n * @param expression expression to check\r\n * @param min count min\r\n * @param max count max\r\n * @returns new expression following pattern\r\n */\r\nfunction createOccurenceExpression(\r\n\texpression: string,\r\n\tmin: number,\r\n\tmax?: number\r\n) {\r\n\treturn all(createOccurencePattern(expression), range(min, max));\r\n}\r\n\r\n/**\r\n * Perform matching of string to validation pattern.\r\n * Function calculates execution time and return it with result\r\n * @param {String} value input value\r\n * @param {IExpressionPattern} pattern validation pattern\r\n * @param {String} flags - optional - regExp flags\r\n * @returns {IMatchResult} Match result\r\n */\r\nexport function matches(\r\n\tvalue: string,\r\n\tpattern: string | RegExp,\r\n): IMatchResult {\r\n\tlet result: IMatchResult = {\r\n\t\tresult: false,\r\n\t\torigin: null,\r\n\t\tpattern: null,\r\n\t\tinput: value,\r\n\t\ttime: -1,\r\n\t};\r\n\tif (!value) {\r\n\t\treturn result;\r\n\t}\r\n\tconst t1 = performance.now();\r\n\ttry {\r\n\t\tconst matchResult = value.match(pattern);\r\n\t\tresult.pattern = pattern;\r\n\t\tresult.result = matchResult !== null;\r\n\t\tresult.origin = matchResult;\r\n\t} catch (e) {\r\n\t\tresult.error = e;\r\n\t} finally {\r\n\t\tresult.time = performance.now() - t1;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Merges expressions into string\r\n * @param {String[]} expressions expressions\r\n * @returns pattern\r\n */\r\nfunction expression(expressions: string[]): string {\r\n\treturn expressions.join(\"\");\r\n}\r\n\r\n/**\r\n * Creates pattern ^value$\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function all(...value: string[]): string {\r\n\treturn `^${expression(value)}$`;\r\n}\r\n\r\n/**\r\n * Creates pattern (value)\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function group(...value: string[]): string {\r\n\treturn `(${expression(value)})`;\r\n}\r\n\r\n/**\r\n * Creates pattern value|value|value...\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function or(...value: string[]): string {\r\n\treturn value.join(\"|\");\r\n}\r\n\r\n/**\r\n * Creates pattern [value]\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function oneOf(...value: string[]): string {\r\n\treturn `[${expression(value)}]`;\r\n}\r\n\r\n/**\r\n * Creates pattern [^value]\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function notOneOf(...value: string[]): string {\r\n\treturn `[^${expression(value)}]`;\r\n}\r\n\r\n/**\r\n * Creates pattern (?=value)\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function positiveLookahead(...value: string[]): string {\r\n\treturn group(\"?=\", ...value);\r\n}\r\n\r\n/**\r\n * Creates pattern (?!value)\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function negativeLookahead(...value: string[]): string {\r\n\treturn group(\"?!\", ...value);\r\n}\r\n\r\n/**\r\n * Creates range pattern {min, max}\r\n * When min === max then pattern is {min}\r\n * @param min range min\r\n * @param max range max\r\n * @returns pattern\r\n */\r\nexport function range(min: number, max?: number) {\r\n\treturn min === max ? `{${min}}` : `{${min},${max ?? \"\"}}`;\r\n}\r\n\r\n/**\r\n * Creates pattern value+\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function atLeastOne(...value: string[]) {\r\n\treturn `${expression(value)}+`;\r\n}\r\n/**\r\n * Creates pattern value*\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function noneOrMore(...value: string[]) {\r\n\treturn `${expression(value)}*`;\r\n}\r\n\r\n/**\r\n * Creates pattern value?\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function noneOrOne(...value: string[]) {\r\n\treturn `${expression(value)}?`;\r\n}\r\n\r\nexport const capitalLetters = \"A-Z\";\r\nexport const lowerLetters = \"a-z\";\r\nexport const digit = \"\\\\d\";\r\nexport const notDigit = \"\\\\D\";\r\nexport const whitespace = \"\\\\s\";\r\nexport const notWhitespace = \"\\\\S\";\r\nexport const word = \"\\\\w\";\r\nexport const notWord = \"\\\\W\";\r\nexport const any = \".\";\r\nexport const specialCharacters = \"\\\\!\\\\*\\\\_\\\\?\\\\+\\\\=\\\\^\\\\$-@%#&\";\r\n\r\n/**\r\n * Helper class that builds regex validation pattern for strings\r\n * Logic is based on positive lookahead pattern. Expression is created from set of such rules\r\n */\r\nexport default class ValidationPattern\r\n\timplements IValidationPattern, IExpressionPattern\r\n{\r\n\tprivate _list: string[];\r\n\tconstructor(init?: string) {\r\n\t\tthis._list = [];\r\n\t\tif (init) {\r\n\t\t\tthis._list.push(init);\r\n\t\t}\r\n\t}\r\n\r\n\texpr(...expressions: string[]): IValidationPattern {\r\n\t\tthis._list.push(...expressions);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string passes some condition\r\n\t * @param {String} expression - expression to check\r\n\t * @returns instance\r\n\t */\r\n\tcheck(expression: string): IValidationPattern {\r\n\t\treturn this.expr(positiveLookahead(expression));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates length of the string\r\n\t * If max is not provided then only minimum is checked\r\n\t * If min == max then string length shall equal exactly min\r\n\t * @param {Number} min - minimum number of occurences\r\n\t * @param {Number} max - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\tofLength(min: number, max?: number): IValidationPattern {\r\n\t\treturn this.check(all(`.${range(min, max)}`));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates whether string contains capital letters\r\n\t * @param {Number} count - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\twithCapital(count?: number): IValidationPattern {\r\n\t\treturn this.check(createOccurenceExpression(capitalLetters, 1, count));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates whether string contains lower cased letters\r\n\t * @param {Number} count - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\twithLower(count?: number): IValidationPattern {\r\n\t\treturn this.check(createOccurenceExpression(lowerLetters, 1, count));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates whether string contains whitespaces\r\n\t * @param {Number} count - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\twithWhitespace(count?: number): IValidationPattern {\r\n\t\treturn this.check(createOccurenceExpression(whitespace, 1, count));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string contain any of the characters\r\n\t * @param {String} characters - characters to check\r\n\t * @returns instance\r\n\t */\r\n\twithAnyOf(characters?: string): IValidationPattern {\r\n\t\tconst specialChars = characters ?? specialCharacters;\r\n\t\treturn this.check(createOccurenceExpression(specialChars, 1));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string does not contain characters\r\n\t * Pattern looks like: (?=^((?![characters]]).)*$)\r\n\t * @param characters - string containing characters that shall not be in input\r\n\t * @returns instance\r\n\t */\r\n\twithNoneOf(characters: string): IValidationPattern {\r\n\t\treturn this.check(\r\n\t\t\tall(group(negativeLookahead(oneOf(characters)), \".\"), \"*\")\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string contains digits\r\n\t * @param {Number} count - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\twithDigits(count?: number): IValidationPattern {\r\n\t\treturn this.check(createOccurenceExpression(digit, 1, count));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string does not contain whitespaces\r\n\t * @returns instance\r\n\t */\r\n\tnoWhitespace(): IValidationPattern {\r\n\t\treturn this.check(all(notWhitespace, \"+\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string contains only digits\r\n\t * @returns instance\r\n\t */\r\n\tdigitsOnly(): IValidationPattern {\r\n\t\treturn this.check(all(digit, \"+\"));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates if string contains word only characters (a-zA-Z0-9_)\r\n\t * @returns instance\r\n\t */\r\n\twordOnly(): IValidationPattern {\r\n\t\treturn this.check(all(word, \"+\"));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates if string does not contain any digit\r\n\t * @returns instance\r\n\t */\r\n\tnoDigits(): IValidationPattern {\r\n\t\treturn this.check(all(notDigit, \"+\"));\r\n\t}\r\n\r\n\ttoString(): string {\r\n\t\treturn this._list.join(\"\");\r\n\t}\r\n\r\n\t/**\r\n\t * Creates regular expression from string representation of the instance\r\n\t * @param flags - regex flags\r\n\t * @returns {RegExp} regular exporession\r\n\t */\r\n\ttoExpression(flags?: string): RegExp {\r\n\t\treturn new RegExp(\"^\" + this.toString() + \".*$\", flags);\r\n\t}\r\n}\r\n"],"sourceRoot":""}