{"version":3,"sources":["webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/universalModuleDefinition","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/bootstrap","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/define property getters","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/hasOwnProperty shorthand","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/make namespace object","webpack://bpdToolkit.[name].bpdToolkit.[name]/./src/validator.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ValidateFunctionError","Error","fname","message","super","this","name","getLength","parseInt","parseFieldStructure","fieldDef","callbacks","field","callback","getCallbackForField","push","min","max","equal","match","ofType","compare","Array","isArray","length","range","minVal","failMessage","maxVal","fieldName","parent","len","result","toString","is","typeString","validateSingleValue","options","helper","validationError","steps","add","undefined","validationErrorHelper","shallContinue","checkAll","validators","isExist","vLen","i","validator","err","fin","error","validate","object","schema","init","validationRes","data","errors","setProp","validationResultsHelper","singleRes","schemaStructure","parseSchemaStructure","builder","set","fields","forEach","build"],"mappings":"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","file":"bpdToolkit.validator.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpdToolkit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpdToolkit\"] = factory();\n\telse\n\t\troot[\"bpdToolkit\"] = root[\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"validator\"] = root[\"bpdToolkit\"][\"validator\"] || {}, root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"] = root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"][\"validator\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export interface ValidationResult {\r\n\tresult: boolean;\r\n\terror?: ValidationError;\r\n}\r\n\r\nexport interface ValidationResults<T> {\r\n\tresult: boolean;\r\n\terrors?: ValidationError[];\r\n\tdata?: T;\r\n}\r\n\r\nexport interface ValidationOptions {\r\n\tcheckAll?: boolean;\r\n}\r\n\r\nexport interface ValidationError {\r\n\tprop?: string;\r\n\tsteps: ValidationErrorStep[];\r\n}\r\n\r\nexport interface ValidationErrorStep {\r\n\tmessage: string;\r\n\tname: string;\r\n}\r\n\r\nexport interface ValidatonSchema<T> {\r\n\t[id: string]: ValidationCallback<T>[];\r\n}\r\n\r\nexport interface SchemaField<T> {\r\n\tname: keyof T;\r\n\tcallbacks: ValidationCallback<T>[];\r\n}\r\n\r\nexport interface ValidationCallback<T> {\r\n\tname: string;\r\n\tfailMessage: string;\r\n\tcallback: (obj: any, name: keyof T, parent: T) => boolean;\r\n}\r\n\r\nexport interface SchemaFieldBuilderBase<T> {\r\n\tbuild(): SchemaField<T>;\r\n}\r\n\r\nexport interface SchemaFieldBuilder<T> extends SchemaFieldBuilderBase<T> {\r\n\tset(...callbacks: ValidationCallback<T>[]): SchemaFieldBuilder<T>;\r\n}\r\n\r\nexport interface SchemaBuilderBase<T> {\r\n\tbuild(): ValidatonSchema<T>;\r\n}\r\n\r\nexport interface SchemaBuilder<T> extends SchemaBuilderBase<T> {\r\n\tset(name: keyof T, ...callbacks: ValidationCallback<T>[]): SchemaBuilder<T>;\r\n\tdefine(...fields: SchemaFieldBuilderBase<T>[]): SchemaBuilder<T>;\r\n}\r\n\r\nexport interface SchemaStructure<T> {\r\n\t[id: string]: SchemaFieldStructure<T>;\r\n}\r\n\r\nexport interface SchemaFieldStructure<T> {\r\n\tmin?: number | [number, string];\r\n\tmax?: number | [number, string];\r\n\trange?: number[] | [number, number, string];\r\n\ttype?: string | string[];\r\n\trequired?: boolean | [boolean, string];\r\n\tmatch?: string | RegExp | [string | RegExp, string];\r\n\tequal?: any | any[];\r\n\tcompare?: string;\r\n\tcustom?: ValidationCallback<T>;\r\n}\r\n\r\n// Errors\r\n\r\nclass ValidateFunctionError extends Error {\r\n\tconstructor(fname: string, message: string) {\r\n\t\tsuper(`Error in function: ${fname}: ${message}`);\r\n\t\tthis.name = \"ValidateFunctionError\";\r\n\t}\r\n}\r\n\r\n// Helper functions\r\n\r\nfunction getLength(obj: any): number {\r\n\tif (typeof obj === \"number\") {\r\n\t\treturn obj;\r\n\t}\r\n\tif (obj[\"length\"] && typeof obj[\"length\"] === \"number\") {\r\n\t\treturn obj[\"length\"];\r\n\t}\r\n\treturn parseInt(obj);\r\n}\r\n\r\nfunction isExist(obj: any) {\r\n\treturn typeof obj !== \"undefined\" && obj !== null;\r\n}\r\n\r\nfunction validationErrorHelper(prop?: string) {\r\n\tconst validationError: ValidationError = {\r\n\t\tprop: prop,\r\n\t\tsteps: [],\r\n\t};\r\n\treturn {\r\n\t\tadd: (name: string, message: string) => {\r\n\t\t\tvalidationError.steps.push({ name, message });\r\n\t\t},\r\n\t\tget: (): ValidationError | undefined => {\r\n\t\t\treturn validationError.steps.length === 0\r\n\t\t\t\t? undefined\r\n\t\t\t\t: validationError;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nfunction validationResultsHelper<T extends V, V>(init?: T) {\r\n\tconst validationRes: ValidationResults<T> = {\r\n\t\tresult: true,\r\n\t\tdata: init,\r\n\t};\r\n\treturn {\r\n\t\tadd: (error: ValidationError) => {\r\n\t\t\tif (!validationRes.errors) {\r\n\t\t\t\tvalidationRes.errors = [];\r\n\t\t\t}\r\n\t\t\tvalidationRes.result = false;\r\n\t\t\tvalidationRes.errors.push(error);\r\n\t\t},\r\n\t\tsetProp: (prop: keyof T, value: any) => {\r\n\t\t\tif (!validationRes.data) return;\r\n\t\t\tvalidationRes.data[prop] = value;\r\n\t\t},\r\n\t\tget: (): ValidationResults<T> => {\r\n\t\t\tif (!validationRes.result) {\r\n\t\t\t\tvalidationRes.data = undefined;\r\n\t\t\t}\r\n\t\t\treturn validationRes;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nfunction parseSchemaStructure<T>(\r\n\tschema: SchemaStructure<T>\r\n): ValidatonSchema<T> {\r\n\tconst result: ValidatonSchema<T> = {};\r\n\tfor (let prop in schema) {\r\n\t\tresult[prop] = parseFieldStructure(schema[prop]);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction parseFieldStructure<T>(\r\n\tfieldDef: SchemaFieldStructure<T>\r\n): ValidationCallback<T>[] {\r\n\tconst callbacks: ValidationCallback<T>[] = [];\r\n\tfor (let field in fieldDef) {\r\n\t\tconst callback = getCallbackForField<T>(\r\n\t\t\t<keyof SchemaFieldStructure<T>>field,\r\n\t\t\tfieldDef[<keyof SchemaFieldStructure<T>>field]\r\n\t\t);\r\n\r\n\t\tif (callback) {\r\n\t\t\tcallbacks.push(callback);\r\n\t\t}\r\n\t}\r\n\treturn callbacks;\r\n}\r\n\r\nfunction getCallbackForField<T>(\r\n\tfield: keyof SchemaFieldStructure<T>,\r\n\tvalue: any\r\n): ValidationCallback<T> | undefined {\r\n\tswitch (field) {\r\n\t\tcase \"min\":\r\n\t\t\treturn min(value);\r\n\t\tcase \"max\":\r\n\t\t\treturn max(value);\r\n\t\tcase \"equal\":\r\n\t\t\treturn equal(value);\r\n\t\tcase \"match\":\r\n\t\t\treturn match(value);\r\n\t\tcase \"type\":\r\n\t\t\treturn ofType(value);\r\n\t\tcase \"compare\":\r\n\t\t\treturn compare(value);\r\n\t\tcase \"range\": {\r\n\t\t\tif (!Array.isArray(value) || value.length < 2) {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t\treturn range(value[0], value[1]);\r\n\t\t}\r\n\t\tcase \"custom\": {\r\n\t\t\tif (value && value[\"name\"] && value[\"callback\"]) {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\tdefault:\r\n\t\t\treturn undefined;\r\n\t}\r\n}\r\n\r\nfunction exists(message?: string) {\r\n\treturn {\r\n\t\tname: \"exists\",\r\n\t\tfailMessage: message ?? \"Does not exist\",\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn isExist(obj);\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Validator callbacks\r\n */\r\n\r\n/**\r\n * Check whether value (or length) is larger or equal to comapre\r\n * @param minVal value to comapre with current field\r\n * @param message\r\n * @returns\r\n */\r\nexport function min<T>(\r\n\tminVal: number,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\tif (typeof minVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"min\", \"Input param is incorrect\");\r\n\t}\r\n\treturn {\r\n\t\tname: \"min\",\r\n\t\tfailMessage: message ?? \"Is lesser than \" + minVal,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn getLength(obj) >= minVal;\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Check whether value (or length) is smaller or equal to value\r\n * @param maxVal - value to compare current field with\r\n * @param message\r\n * @returns\r\n */\r\nexport function max<T>(\r\n\tmaxVal: number,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\tif (typeof maxVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"max\", \"Input param is incorrect\");\r\n\t}\r\n\treturn {\r\n\t\tname: \"max\",\r\n\t\tfailMessage: message ?? \"Is greater than \" + maxVal,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn getLength(obj) <= maxVal;\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Compares whether values of two fields are equal\r\n * @param fieldName field to compare with current\r\n * @param message\r\n * @returns\r\n */\r\nexport function compare<T>(\r\n\tfieldName: string,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\tif (typeof fieldName !== \"string\") {\r\n\t\tthrow new ValidateFunctionError(\"compare\", \"Input param is incorrect\");\r\n\t}\r\n\treturn {\r\n\t\tname: \"compare\",\r\n\t\tfailMessage: message ?? \"Is different than \" + fieldName,\r\n\t\tcallback: (obj: any, name: keyof T, parent: T) => {\r\n\t\t\treturn (<any>parent)[fieldName] === obj;\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Checks if value is within the range (for strings and array length is compared)\r\n * @param {Number} minVal - minmum range value\r\n * @param {Number} maxVal - max range value\r\n * @param {String} message\r\n * @returns\r\n */\r\nexport function range<T>(\r\n\tminVal: number,\r\n\tmaxVal: number,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\tif (typeof maxVal !== \"number\" || typeof minVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"range\", \"Incorrect input params\");\r\n\t}\r\n\tif (minVal >= maxVal) {\r\n\t\tthrow new ValidateFunctionError(\"range\", \"Incorrect range provided\");\r\n\t}\r\n\treturn {\r\n\t\tname: \"range\",\r\n\t\tfailMessage: message ?? `Doesn't match range ${minVal} and ${maxVal}`,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\tconst len = getLength(obj);\r\n\t\t\treturn len >= minVal && len <= maxVal;\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Matches field value with compare string or regex\r\n * @param {String | RegExp} compare\r\n * @param {String} message\r\n * @returns\r\n */\r\nexport function match<T>(\r\n\tcompare: string | RegExp,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\treturn {\r\n\t\tname: \"match\",\r\n\t\tfailMessage: message ?? `Doesn't match to ${compare}`,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\tif (!obj) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tconst result =\r\n\t\t\t\ttypeof obj === \"string\"\r\n\t\t\t\t\t? obj.match(compare)\r\n\t\t\t\t\t: obj.toString().match(compare);\r\n\r\n\t\t\treturn result !== null && result.length > 0;\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Checks if field value equals to compare\r\n * @param {any} compare Value to compore field with\r\n * @param {String} message\r\n * @returns\r\n */\r\nexport function equal<T>(\r\n\tcompare: any,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\treturn {\r\n\t\tname: \"equal\",\r\n\t\tfailMessage: message ?? \"Does not equal to \" + compare,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn Object.is(obj, compare);\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Check if field value is of expected type\r\n * @param {String} typeString - exprected type of the field\r\n * @param {String} message\r\n * @returns\r\n */\r\nexport function ofType<T>(\r\n\ttypeString: string,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\treturn {\r\n\t\tname: \"ofType\",\r\n\t\tfailMessage: message ?? \"Type doesn't match to \" + typeString,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn typeof obj === typeString;\r\n\t\t},\r\n\t};\r\n}\r\n\r\n////////////////////////////////\r\n\r\nexport function validateSingleValue<T>(\r\n\tprop: keyof T,\r\n\tvalue: any,\r\n\tparent: T,\r\n\tcallbacks: ValidationCallback<T>[],\r\n\toptions?: ValidationOptions\r\n): ValidationResult {\r\n\tconst helper = validationErrorHelper(prop as string);\r\n\tconst shallContinue = options?.checkAll;\r\n\tconst validators = [exists(), ...callbacks];\r\n\tconst vLen = validators.length;\r\n\r\n\tfor (let i = 0; i < vLen; i++) {\r\n\t\tconst validator = validators[i];\r\n\t\ttry {\r\n\t\t\tif (!validator.callback(value, prop, parent)) {\r\n\t\t\t\thelper.add(validator.name, validator.failMessage);\r\n\t\t\t\tif (!shallContinue) break;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\thelper.add(validator.name, `[Validator failure] ${err.message}`);\r\n\t\t\tif (!shallContinue) break;\r\n\t\t}\r\n\t}\r\n\r\n\tconst fin = helper.get();\r\n\treturn {\r\n\t\tresult: fin === undefined,\r\n\t\terror: fin,\r\n\t};\r\n}\r\n\r\nexport function validate<T extends V, V>(\r\n\tobject: any,\r\n\tschema: ValidatonSchema<V>,\r\n\toptions?: ValidationOptions\r\n): ValidationResults<T> {\r\n\tconst helper = validationResultsHelper<T, V>();\r\n\tfor (let prop in schema) {\r\n\t\tconst value = object[prop];\r\n\t\tconst singleRes = validateSingleValue(\r\n\t\t\tprop,\r\n\t\t\tvalue,\r\n\t\t\tobject,\r\n\t\t\tschema[prop],\r\n\t\t\toptions\r\n\t\t);\r\n\r\n\t\tif (singleRes.result) {\r\n\t\t\thelper.setProp(prop as any, value);\r\n\t\t} else {\r\n\t\t\tif (singleRes.error) helper.add(singleRes.error);\r\n\t\t\tif (!options?.checkAll) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn helper.get();\r\n}\r\n\r\nexport function schema<T>(\r\n\tschemaStructure?: SchemaStructure<T>\r\n): SchemaBuilder<T> {\r\n\tconst schema: ValidatonSchema<T> = schemaStructure\r\n\t\t? parseSchemaStructure(schemaStructure)\r\n\t\t: {};\r\n\tconst builder: SchemaBuilder<T> = {\r\n\t\tset: (name: keyof T, ...callbacks: ValidationCallback<T>[]) => {\r\n\t\t\tschema[name as string] = callbacks;\r\n\t\t\treturn builder;\r\n\t\t},\r\n\t\tdefine: (...fields: SchemaFieldBuilderBase<T>[]) => {\r\n\t\t\tfields.forEach((field) => {\r\n\t\t\t\tconst { name, callbacks } = field.build();\r\n\t\t\t\tschema[name as string] = callbacks;\r\n\t\t\t});\r\n\t\t\treturn builder;\r\n\t\t},\r\n\t\tbuild: () => {\r\n\t\t\treturn schema;\r\n\t\t},\r\n\t};\r\n\treturn builder;\r\n}\r\n\r\nexport function field<T>(name: keyof T): SchemaFieldBuilder<T> {\r\n\tconst callbacks: ValidationCallback<T>[] = [];\r\n\tconst builder = {\r\n\t\tset: (...validators: ValidationCallback<T>[]) => {\r\n\t\t\tif (!validators) throw new Error(\"Callback not provided\");\r\n\t\t\tcallbacks.push(...validators);\r\n\t\t\treturn builder;\r\n\t\t},\r\n\r\n\t\tbuild: (): SchemaField<T> => {\r\n\t\t\treturn {\r\n\t\t\t\tname,\r\n\t\t\t\tcallbacks,\r\n\t\t\t};\r\n\t\t},\r\n\t};\r\n\treturn builder;\r\n}\r\n"],"sourceRoot":""}