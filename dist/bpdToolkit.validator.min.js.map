{"version":3,"sources":["webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/universalModuleDefinition","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/bootstrap","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/define property getters","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/hasOwnProperty shorthand","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/make namespace object","webpack://bpdToolkit.[name].bpdToolkit.[name]/./src/validator.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ValidateFunctionError","Error","fname","message","super","this","name","getLength","parseInt","parseFieldStructure","fieldDef","callbacks","field","callback","getCallbackForField","push","min","max","equal","match","ofType","Array","isArray","length","range","minVal","failMessage","maxVal","len","compare","result","toString","is","typeString","validateSingleValue","options","helper","validationError","steps","add","undefined","validationErrorHelper","shallContinue","checkAll","validators","isExist","vLen","i","validator","err","fin","error","validate","object","schema","init","validationRes","data","errors","setProp","validationResultsHelper","singleRes","schemaStructure","parseSchemaStructure","builder","set","fields","forEach","build"],"mappings":"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","file":"bpdToolkit.validator.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpdToolkit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpdToolkit\"] = factory();\n\telse\n\t\troot[\"bpdToolkit\"] = root[\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"validator\"] = root[\"bpdToolkit\"][\"validator\"] || {}, root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"] = root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"][\"validator\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export interface ValidationResult {\r\n\tresult: boolean;\r\n\terror?: ValidationError;\r\n}\r\n\r\nexport interface ValidationResults<T> {\r\n\tresult: boolean;\r\n\terrors?: ValidationError[];\r\n\tdata?: T;\r\n}\r\n\r\nexport interface ValidationOptions {\r\n\tcheckAll?: boolean;\r\n}\r\n\r\nexport interface ValidationError {\r\n\tprop?: string;\r\n\tsteps: ValidationErrorStep[];\r\n}\r\n\r\nexport interface ValidationErrorStep {\r\n\tmessage: string;\r\n\tname: string;\r\n}\r\n\r\nexport interface ValidatonSchema {\r\n\t[id: string]: ValidationCallback[];\r\n}\r\n\r\nexport interface SchemaField<T> {\r\n\tname: keyof T;\r\n\tcallbacks: ValidationCallback[];\r\n}\r\n\r\nexport interface ValidationCallback {\r\n\tname: string;\r\n\tfailMessage: string;\r\n\tcallback: (obj: any) => boolean;\r\n}\r\n\r\nexport interface SchemaFieldBuilderBase<T> {\r\n\tbuild(): SchemaField<T>;\r\n}\r\n\r\nexport interface SchemaFieldBuilder<T> extends SchemaFieldBuilderBase<T> {\r\n\tset(...callbacks: ValidationCallback[]): SchemaFieldBuilder<T>;\r\n}\r\n\r\nexport interface SchemaBuilderBase {\r\n\tbuild(): ValidatonSchema;\r\n}\r\n\r\nexport interface SchemaBuilder<T> extends SchemaBuilderBase {\r\n\tset(name: keyof T, ...callbacks: ValidationCallback[]): SchemaBuilder<T>;\r\n\tdefine(...fields: SchemaFieldBuilderBase<T>[]): SchemaBuilder<T>;\r\n}\r\n\r\nexport interface SchemaStructure {\r\n\t[id: string]: SchemaFieldStructure;\r\n}\r\n\r\nexport interface SchemaFieldStructure {\r\n\tmin?: number | [number, string];\r\n\tmax?: number | [number, string];\r\n\trange?: number[] | [number, number, string];\r\n\ttype?: string | string[];\r\n\trequired?: boolean | [boolean, string];\r\n\tmatch?: string | RegExp | [string | RegExp, string];\r\n\tequal?: any | any[];\r\n\tcustom?: ValidationCallback;\r\n}\r\n\r\n// Errors\r\n\r\nclass ValidateFunctionError extends Error {\r\n\tconstructor(fname: string, message: string) {\r\n\t\tsuper(`Error in function: ${fname}: ${message}`);\r\n\t\tthis.name = \"ValidateFunctionError\";\r\n\t}\r\n}\r\n\r\n// Helper functions\r\n\r\nfunction getLength(obj: any): number {\r\n\tif (typeof obj === \"number\") {\r\n\t\treturn obj;\r\n\t}\r\n\tif (obj[\"length\"] && typeof obj[\"length\"] === \"number\") {\r\n\t\treturn obj[\"length\"];\r\n\t}\r\n\treturn parseInt(obj);\r\n}\r\n\r\nfunction isExist(obj: any) {\r\n\treturn typeof obj !== \"undefined\" && obj !== null;\r\n}\r\n\r\nfunction validationErrorHelper(prop?: string) {\r\n\tconst validationError: ValidationError = {\r\n\t\tprop: prop,\r\n\t\tsteps: [],\r\n\t};\r\n\treturn {\r\n\t\tadd: (name: string, message: string) => {\r\n\t\t\tvalidationError.steps.push({ name, message });\r\n\t\t},\r\n\t\tget: (): ValidationError | undefined => {\r\n\t\t\treturn validationError.steps.length === 0\r\n\t\t\t\t? undefined\r\n\t\t\t\t: validationError;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nfunction validationResultsHelper<T extends V, V>(init?: T) {\r\n\tconst validationRes: ValidationResults<T> = {\r\n\t\tresult: true,\r\n\t\tdata: init,\r\n\t};\r\n\treturn {\r\n\t\tadd: (error: ValidationError) => {\r\n\t\t\tif (!validationRes.errors) {\r\n\t\t\t\tvalidationRes.errors = [];\r\n\t\t\t}\r\n\t\t\tvalidationRes.result = false;\r\n\t\t\tvalidationRes.errors.push(error);\r\n\t\t},\r\n\t\tsetProp: (prop: keyof T, value: any) => {\r\n\t\t\tif (!validationRes.data) return;\r\n\t\t\tvalidationRes.data[prop] = value;\r\n\t\t},\r\n\t\tget: (): ValidationResults<T> => {\r\n\t\t\tif (!validationRes.result) {\r\n\t\t\t\tvalidationRes.data = undefined;\r\n\t\t\t}\r\n\t\t\treturn validationRes;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nfunction parseSchemaStructure(schema: SchemaStructure): ValidatonSchema {\r\n\tconst result: ValidatonSchema = {};\r\n\tfor (let prop in schema) {\r\n\t\tresult[prop] = parseFieldStructure(schema[prop]);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction parseFieldStructure(\r\n\tfieldDef: SchemaFieldStructure\r\n): ValidationCallback[] {\r\n\tconst callbacks: ValidationCallback[] = [];\r\n\tfor (let field in fieldDef) {\r\n\t\tconst callback = getCallbackForField(\r\n\t\t\t<keyof SchemaFieldStructure>field,\r\n\t\t\tfieldDef[<keyof SchemaFieldStructure>field]\r\n\t\t);\r\n\r\n\t\tif (callback) {\r\n\t\t\tcallbacks.push(callback);\r\n\t\t}\r\n\t}\r\n\treturn callbacks;\r\n}\r\n\r\nfunction getCallbackForField(\r\n\tfield: keyof SchemaFieldStructure,\r\n\tvalue: any\r\n): ValidationCallback | undefined {\r\n\tswitch (field) {\r\n\t\tcase \"min\":\r\n\t\t\treturn min(value);\r\n\t\tcase \"max\":\r\n\t\t\treturn max(value);\r\n\t\tcase \"equal\":\r\n\t\t\treturn equal(value);\r\n\t\tcase \"match\":\r\n\t\t\treturn match(value);\r\n\t\tcase \"type\":\r\n\t\t\treturn ofType(value);\r\n\t\tcase \"range\": {\r\n\t\t\tif (!Array.isArray(value) || value.length < 2) {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t\treturn range(value[0], value[1]);\r\n\t\t}\r\n\t\tcase \"custom\": {\r\n\t\t\tif (value && value[\"name\"] && value[\"callback\"]) {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\tdefault:\r\n\t\t\treturn undefined;\r\n\t}\r\n}\r\n\r\nfunction exists(message?: string) {\r\n\treturn {\r\n\t\tname: \"exists\",\r\n\t\tfailMessage: message ?? \"Does not exist\",\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn isExist(obj);\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Validator callbacks\r\n */\r\n\r\nexport function min(minVal: number, message?: string): ValidationCallback {\r\n\tif (typeof minVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"min\", \"Input param is incorrect\");\r\n\t}\r\n\treturn {\r\n\t\tname: \"min\",\r\n\t\tfailMessage: message ?? \"Is lesser than \" + minVal,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn getLength(obj) >= minVal;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nexport function max(maxVal: number, message?: string): ValidationCallback {\r\n\tif (typeof maxVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"max\", \"Input param is incorrect\");\r\n\t}\r\n\treturn {\r\n\t\tname: \"max\",\r\n\t\tfailMessage: message ?? \"Is greater than \" + maxVal,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn getLength(obj) <= maxVal;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nexport function range(\r\n\tminVal: number,\r\n\tmaxVal: number,\r\n\tmessage?: string\r\n): ValidationCallback {\r\n\tif (typeof maxVal !== \"number\" || typeof minVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"range\", \"Incorrect input params\");\r\n\t}\r\n\tif (minVal >= maxVal) {\r\n\t\tthrow new ValidateFunctionError(\"range\", \"Incorrect range provided\");\r\n\t}\r\n\treturn {\r\n\t\tname: \"range\",\r\n\t\tfailMessage: message ?? `Doesn't match range ${minVal} and ${maxVal}`,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\tconst len = getLength(obj);\r\n\t\t\treturn len >= minVal && len <= maxVal;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nexport function match(\r\n\tcompare: string | RegExp,\r\n\tmessage?: string\r\n): ValidationCallback {\r\n\treturn {\r\n\t\tname: \"match\",\r\n\t\tfailMessage: message ?? `Doesn't match to ${compare}`,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\tif (!obj) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tconst result =\r\n\t\t\t\ttypeof obj === \"string\"\r\n\t\t\t\t\t? obj.match(compare)\r\n\t\t\t\t\t: obj.toString().match(compare);\r\n\r\n\t\t\treturn result !== null && result.length > 0;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nexport function equal(compare: any, message?: string) {\r\n\treturn {\r\n\t\tname: \"equal\",\r\n\t\tfailMessage: message ?? \"Does not equal to \" + compare,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn Object.is(obj, compare);\r\n\t\t},\r\n\t};\r\n}\r\n\r\nexport function ofType(typeString: string, message?: string) {\r\n\treturn {\r\n\t\tname: \"ofType\",\r\n\t\tfailMessage: message ?? \"Type doesn't match to \" + typeString,\r\n\t\tcallback: (obj: any) => {\r\n\t\t\treturn typeof obj === typeString;\r\n\t\t},\r\n\t};\r\n}\r\n\r\n////////////////////////////////\r\n\r\nexport function validateSingleValue(\r\n\tprop: string,\r\n\tvalue: any,\r\n\tcallbacks: ValidationCallback[],\r\n\toptions?: ValidationOptions\r\n): ValidationResult {\r\n\tconst helper = validationErrorHelper(prop);\r\n\tconst shallContinue = options?.checkAll;\r\n\tconst validators = [exists(), ...callbacks];\r\n\tconst vLen = validators.length;\r\n\r\n\tfor (let i = 0; i < vLen; i++) {\r\n\t\tconst validator = validators[i];\r\n\t\ttry {\r\n\t\t\tif (!validator.callback(value)) {\r\n\t\t\t\thelper.add(validator.name, validator.failMessage);\r\n\t\t\t\tif (!shallContinue) break;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\thelper.add(validator.name, `[Validator failure] ${err.message}`);\r\n\t\t\tif (!shallContinue) break;\r\n\t\t}\r\n\t}\r\n\r\n\tconst fin = helper.get();\r\n\treturn {\r\n\t\tresult: fin === undefined,\r\n\t\terror: fin,\r\n\t};\r\n}\r\n\r\nexport function validate<T extends V, V>(\r\n\tobject: any,\r\n\tschema: ValidatonSchema,\r\n\toptions?: ValidationOptions\r\n): ValidationResults<T> {\r\n\tconst helper = validationResultsHelper<T, V>();\r\n\tfor (let prop in schema) {\r\n\t\tconst value = object[prop];\r\n\t\tconst singleRes = validateSingleValue(\r\n\t\t\tprop,\r\n\t\t\tvalue,\r\n\t\t\tschema[prop],\r\n\t\t\toptions\r\n\t\t);\r\n\r\n\t\tif (singleRes.result) {\r\n\t\t\thelper.setProp(prop as any, value);\r\n\t\t} else {\r\n\t\t\tif (singleRes.error) helper.add(singleRes.error);\r\n\t\t\tif (!options?.checkAll) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn helper.get();\r\n}\r\n\r\nexport function schema<T>(schemaStructure?: SchemaStructure): SchemaBuilder<T> {\r\n\tconst schema: ValidatonSchema = schemaStructure\r\n\t\t? parseSchemaStructure(schemaStructure)\r\n\t\t: {};\r\n\tconst builder: SchemaBuilder<T> = {\r\n\t\tset: (name: keyof T, ...callbacks: ValidationCallback[]) => {\r\n\t\t\tschema[name as string] = callbacks;\r\n\t\t\treturn builder;\r\n\t\t},\r\n\t\tdefine: (...fields: SchemaFieldBuilderBase<T>[]) => {\r\n\t\t\tfields.forEach((field) => {\r\n\t\t\t\tconst { name, callbacks } = field.build();\r\n\t\t\t\tschema[name as string] = callbacks;\r\n\t\t\t});\r\n\t\t\treturn builder;\r\n\t\t},\r\n\t\tbuild: () => {\r\n\t\t\treturn schema;\r\n\t\t},\r\n\t};\r\n\treturn builder;\r\n}\r\n\r\nexport function field<T>(name: keyof T): SchemaFieldBuilder<T> {\r\n\tconst callbacks: ValidationCallback[] = [];\r\n\tconst builder = {\r\n\t\tset: (...validators: ValidationCallback[]) => {\r\n\t\t\tif (!validators) throw new Error(\"Callback not provided\");\r\n\t\t\tcallbacks.push(...validators);\r\n\t\t\treturn builder;\r\n\t\t},\r\n\r\n\t\tbuild: (): SchemaField<T> => {\r\n\t\t\treturn {\r\n\t\t\t\tname,\r\n\t\t\t\tcallbacks,\r\n\t\t\t};\r\n\t\t},\r\n\t};\r\n\treturn builder;\r\n}\r\n"],"sourceRoot":""}