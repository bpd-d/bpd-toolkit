{"version":3,"sources":["webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/universalModuleDefinition","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/bootstrap","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/define property getters","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/hasOwnProperty shorthand","webpack://bpdToolkit.[name].bpdToolkit.[name]/webpack/runtime/make namespace object","webpack://bpdToolkit.[name].bpdToolkit.[name]/./src/validator.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ValidateFunctionError","Error","fname","message","super","this","name","getLength","parseInt","isExist","parseFieldStructure","fieldDef","callbacks","field","callback","getCallbackForField","push","argument","Array","isArray","min","max","equal","match","ofType","compare","length","undefined","range","minVal","status","maxVal","fieldName","parent","len","resultObject","matchResult","toString","is","typeString","validateSingleValue","options","errors","shallContinue","checkAll","validators","vLen","i","validatorResult","err","validate","object","schema","helper","init","validationRes","result","data","add","setProp","validationResultsHelper","singleRes","schemaStructure","parseSchemaStructure","builder","set","fields","forEach","build"],"mappings":"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","file":"bpdToolkit.validator.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpdToolkit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpdToolkit\"] = factory();\n\telse\n\t\troot[\"bpdToolkit\"] = root[\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"validator\"] = root[\"bpdToolkit\"][\"validator\"] || {}, root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"] = root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"validator\"][\"bpdToolkit\"][\"validator\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export interface ValidationResult {\r\n\tresult: boolean;\r\n\terror?: ValidationError;\r\n}\r\n\r\nexport interface ValidationResults<T> {\r\n\tresult: boolean;\r\n\terrors?: ValidationError;\r\n\tdata?: T;\r\n}\r\n\r\nexport interface ValidationOptions {\r\n\tcheckAll?: boolean;\r\n}\r\n\r\nexport interface ValidationError {\r\n\t[id: string]: string[];\r\n}\r\n\r\nexport interface ValidationErrorStep {\r\n\tmessage: string;\r\n\tname: string;\r\n}\r\n\r\nexport interface ValidatonSchema<T> {\r\n\t[id: string]: ValidationCallback<T>[];\r\n}\r\n\r\nexport interface SchemaField<T> {\r\n\tname: keyof T;\r\n\tcallbacks: ValidationCallback<T>[];\r\n}\r\n\r\n// export interface ValidationCallback<T> {\r\n// \tname: string;\r\n// \tfailMessage: string;\r\n// \tcallback: (obj: any, name: keyof T, parent: T) => boolean;\r\n// }\r\nexport interface ValidationCallbackResult {\r\n\tstatus: boolean;\r\n\tmessage?: string;\r\n}\r\nexport interface ValidationCallback<T> {\r\n\t(\r\n\t\tcurrentValue: any,\r\n\t\tcurrentProp: keyof T,\r\n\t\tparent: T\r\n\t): ValidationCallbackResult;\r\n}\r\n\r\nexport interface SchemaFieldBuilderBase<T> {\r\n\tbuild(): SchemaField<T>;\r\n}\r\n\r\nexport interface SchemaFieldBuilder<T> extends SchemaFieldBuilderBase<T> {\r\n\tset(...callbacks: ValidationCallback<T>[]): SchemaFieldBuilder<T>;\r\n}\r\n\r\nexport interface SchemaBuilderBase<T> {\r\n\tbuild(): ValidatonSchema<T>;\r\n}\r\n\r\nexport interface SchemaBuilder<T> extends SchemaBuilderBase<T> {\r\n\tset(name: keyof T, ...callbacks: ValidationCallback<T>[]): SchemaBuilder<T>;\r\n\tdefine(...fields: SchemaFieldBuilderBase<T>[]): SchemaBuilder<T>;\r\n}\r\n\r\nexport interface SchemaStructure<T> {\r\n\t[id: string]: SchemaFieldStructure<T>;\r\n}\r\n\r\nexport interface SchemaFieldStructure<T> {\r\n\tmin?: number | [number, string];\r\n\tmax?: number | [number, string];\r\n\trange?: number[] | [number, number, string];\r\n\ttype?: string | string[];\r\n\trequired?: boolean | [boolean, string];\r\n\tmatch?: string | RegExp | [string | RegExp, string];\r\n\tequal?: any | any[];\r\n\tcompare?: [string, string];\r\n\tcustom?: ValidationCallback<T>;\r\n}\r\n\r\n// Errors\r\n\r\nclass ValidateFunctionError extends Error {\r\n\tconstructor(fname: string, message: string) {\r\n\t\tsuper(`Error in function: ${fname}: ${message}`);\r\n\t\tthis.name = \"ValidateFunctionError\";\r\n\t}\r\n}\r\n\r\n// Helper functions\r\n\r\nfunction getLength(obj: any): number {\r\n\tif (typeof obj === \"number\") {\r\n\t\treturn obj;\r\n\t}\r\n\tif (obj[\"length\"] && typeof obj[\"length\"] === \"number\") {\r\n\t\treturn obj[\"length\"];\r\n\t}\r\n\treturn parseInt(obj);\r\n}\r\n\r\nfunction isExist(obj: any) {\r\n\treturn typeof obj !== \"undefined\" && obj !== null;\r\n}\r\n\r\nfunction validationResultsHelper<T extends V, V>(init?: T) {\r\n\tconst validationRes: ValidationResults<T> = {\r\n\t\tresult: true,\r\n\t\tdata: init,\r\n\t};\r\n\treturn {\r\n\t\tadd: (prop: string, errors: string[]) => {\r\n\t\t\tif (!validationRes.errors) {\r\n\t\t\t\tvalidationRes.errors = {};\r\n\t\t\t}\r\n\t\t\tvalidationRes.result = false;\r\n\t\t\tvalidationRes.errors[prop] = errors;\r\n\t\t},\r\n\t\tsetProp: (prop: keyof T, value: any) => {\r\n\t\t\tif (!validationRes.data) return;\r\n\t\t\tvalidationRes.data[prop] = value;\r\n\t\t},\r\n\t\tget: (): ValidationResults<T> => {\r\n\t\t\tif (!validationRes.result) {\r\n\t\t\t\tvalidationRes.data = undefined;\r\n\t\t\t}\r\n\t\t\treturn validationRes;\r\n\t\t},\r\n\t};\r\n}\r\n\r\nfunction parseSchemaStructure<T>(\r\n\tschema: SchemaStructure<T>\r\n): ValidatonSchema<T> {\r\n\tconst result: ValidatonSchema<T> = {};\r\n\tfor (let prop in schema) {\r\n\t\tresult[prop] = parseFieldStructure(schema[prop]);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction parseFieldStructure<T>(\r\n\tfieldDef: SchemaFieldStructure<T>\r\n): ValidationCallback<T>[] {\r\n\tconst callbacks: ValidationCallback<T>[] = [];\r\n\tfor (let field in fieldDef) {\r\n\t\tconst callback = getCallbackForField<T>(\r\n\t\t\t<keyof SchemaFieldStructure<T>>field,\r\n\t\t\tfieldDef[<keyof SchemaFieldStructure<T>>field]\r\n\t\t);\r\n\r\n\t\tif (callback) {\r\n\t\t\tcallbacks.push(callback);\r\n\t\t}\r\n\t}\r\n\treturn callbacks;\r\n}\r\n\r\nfunction getCallbackForField<T>(\r\n\tfield: keyof SchemaFieldStructure<T>,\r\n\tvalue: any\r\n): ValidationCallback<T> | undefined {\r\n\tlet argument = value;\r\n\tlet message = undefined;\r\n\tif (Array.isArray(value)) {\r\n\t\t[argument, message] = value;\r\n\t}\r\n\tswitch (field) {\r\n\t\tcase \"min\":\r\n\t\t\treturn min(argument);\r\n\t\tcase \"max\":\r\n\t\t\treturn max(argument);\r\n\t\tcase \"equal\":\r\n\t\t\treturn equal(argument);\r\n\t\tcase \"match\":\r\n\t\t\treturn match(argument);\r\n\t\tcase \"type\":\r\n\t\t\treturn ofType(argument);\r\n\t\tcase \"compare\":\r\n\t\t\treturn compare(argument);\r\n\t\tcase \"range\": {\r\n\t\t\tif (!Array.isArray(value) || value.length < 2) {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t\tmessage = value.length > 2 ? value[2] : undefined;\r\n\t\t\treturn range(value[0], value[1], message);\r\n\t\t}\r\n\t\tdefault:\r\n\t\t\treturn undefined;\r\n\t}\r\n}\r\n\r\nfunction exists<T>(message?: string): ValidationCallback<T> {\r\n\treturn (obj: any) => {\r\n\t\treturn {\r\n\t\t\tstatus: isExist(obj),\r\n\t\t\tmessage: message ?? \"Does not exist\",\r\n\t\t};\r\n\t};\r\n}\r\n\r\n/**\r\n * Validator callbacks\r\n */\r\n\r\n/**\r\n * Check whether value (or length) is larger or equal to comapre\r\n * @param minVal value to comapre with current field\r\n * @param message\r\n * @returns\r\n */\r\nexport function min<T>(\r\n\tminVal: number,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\tif (typeof minVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"min\", \"Input param is incorrect\");\r\n\t}\r\n\treturn (obj: any) => {\r\n\t\treturn {\r\n\t\t\tstatus: getLength(obj) >= minVal,\r\n\t\t\tmessage: message ?? \"Is lesser than \" + minVal,\r\n\t\t};\r\n\t};\r\n}\r\n\r\n/**\r\n * Check whether value (or length) is smaller or equal to value\r\n * @param maxVal - value to compare current field with\r\n * @param message\r\n * @returns\r\n */\r\nexport function max<T>(\r\n\tmaxVal: number,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\tif (typeof maxVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"max\", \"Input param is incorrect\");\r\n\t}\r\n\treturn (obj: any) => {\r\n\t\treturn {\r\n\t\t\tstatus: getLength(obj) <= maxVal,\r\n\t\t\tmessage: message ?? \"Is greater than \" + maxVal,\r\n\t\t};\r\n\t};\r\n}\r\n\r\n/**\r\n * Compares whether values of two fields are equal\r\n * @param fieldName field to compare with current\r\n * @param message\r\n * @returns\r\n */\r\nexport function compare<T>(\r\n\tfieldName: string,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\tif (typeof fieldName !== \"string\") {\r\n\t\tthrow new ValidateFunctionError(\"compare\", \"Input param is incorrect\");\r\n\t}\r\n\treturn (obj: any, name: keyof T, parent: T) => {\r\n\t\treturn {\r\n\t\t\tstatus: (<any>parent)[fieldName] === obj,\r\n\t\t\tmessage: message ?? \"Is different than \" + fieldName,\r\n\t\t};\r\n\t};\r\n}\r\n\r\n/**\r\n * Checks if value is within the range (for strings and array length is compared)\r\n * @param {Number} minVal - minmum range value\r\n * @param {Number} maxVal - max range value\r\n * @param {String} message\r\n * @returns\r\n */\r\nexport function range<T>(\r\n\tminVal: number,\r\n\tmaxVal: number,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\tif (typeof maxVal !== \"number\" || typeof minVal !== \"number\") {\r\n\t\tthrow new ValidateFunctionError(\"range\", \"Incorrect input params\");\r\n\t}\r\n\tif (minVal >= maxVal) {\r\n\t\tthrow new ValidateFunctionError(\"range\", \"Incorrect range provided\");\r\n\t}\r\n\treturn (obj: any) => {\r\n\t\tconst len = getLength(obj);\r\n\t\treturn {\r\n\t\t\tstatus: len >= minVal && len <= maxVal,\r\n\t\t\tmessage: message ?? `Doesn't match range ${minVal} and ${maxVal}`,\r\n\t\t};\r\n\t};\r\n}\r\n\r\n/**\r\n * Matches field value with compare string or regex\r\n * @param {String | RegExp} compare\r\n * @param {String} message\r\n * @returns\r\n */\r\nexport function match<T>(\r\n\tcompare: string | RegExp,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\treturn (obj: any) => {\r\n\t\tconst resultObject = {\r\n\t\t\tstatus: false,\r\n\t\t\tmessage: message ?? `Doesn't match to ${compare}`,\r\n\t\t};\r\n\r\n\t\tif (!obj) {\r\n\t\t\treturn resultObject;\r\n\t\t}\r\n\r\n\t\tconst matchResult =\r\n\t\t\ttypeof obj === \"string\"\r\n\t\t\t\t? obj.match(compare)\r\n\t\t\t\t: obj.toString().match(compare);\r\n\t\tresultObject.status = matchResult !== null;\r\n\r\n\t\treturn resultObject;\r\n\t};\r\n}\r\n\r\n/**\r\n * Checks if field value equals to compare\r\n * @param {any} compare Value to compore field with\r\n * @param {String} message\r\n * @returns\r\n */\r\nexport function equal<T>(\r\n\tcompare: any,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\treturn (obj: any) => {\r\n\t\treturn {\r\n\t\t\tstatus: Object.is(obj, compare),\r\n\t\t\tmessage: message ?? \"Does not equal to \" + compare,\r\n\t\t};\r\n\t};\r\n}\r\n\r\n/**\r\n * Check if field value is of expected type\r\n * @param {String} typeString - exprected type of the field\r\n * @param {String} message\r\n * @returns\r\n */\r\nexport function ofType<T>(\r\n\ttypeString: string,\r\n\tmessage?: string\r\n): ValidationCallback<T> {\r\n\treturn (obj: any) => {\r\n\t\treturn {\r\n\t\t\tstatus: typeof obj === typeString,\r\n\t\t\tmessage: message ?? \"Type doesn't match to \" + typeString,\r\n\t\t};\r\n\t};\r\n}\r\n\r\n////////////////////////////////\r\n\r\nexport function validateSingleValue<T>(\r\n\tprop: keyof T,\r\n\tvalue: any,\r\n\tparent: T,\r\n\tcallbacks: ValidationCallback<T>[],\r\n\toptions?: ValidationOptions\r\n): string[] {\r\n\tconst errors: string[] = [];\r\n\tconst shallContinue = options?.checkAll;\r\n\tconst validators = [exists(), ...callbacks];\r\n\tconst vLen = validators.length;\r\n\r\n\tfor (let i = 0; i < vLen; i++) {\r\n\t\tconst validatorResult = (<ValidationCallback<T>>validators[i])(\r\n\t\t\tvalue,\r\n\t\t\tprop,\r\n\t\t\tparent\r\n\t\t);\r\n\t\ttry {\r\n\t\t\tif (!validatorResult.status) {\r\n\t\t\t\terrors.push(validatorResult.message ?? \"Unknown error\");\r\n\r\n\t\t\t\tif (!shallContinue) break;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\terrors.push(\"[Internal] Validation callback error\");\r\n\t\t\tif (!shallContinue) break;\r\n\t\t}\r\n\t}\r\n\r\n\treturn errors;\r\n}\r\n\r\nexport function validate<T extends V, V>(\r\n\tobject: any,\r\n\tschema: ValidatonSchema<V>,\r\n\toptions?: ValidationOptions\r\n): ValidationResults<T> {\r\n\tconst helper = validationResultsHelper<T, V>();\r\n\tfor (let prop in schema) {\r\n\t\tconst value = object[prop];\r\n\t\tconst singleRes = validateSingleValue(\r\n\t\t\tprop,\r\n\t\t\tvalue,\r\n\t\t\tobject,\r\n\t\t\tschema[prop],\r\n\t\t\toptions\r\n\t\t);\r\n\r\n\t\tif (singleRes.length === 0) {\r\n\t\t\thelper.setProp(prop as any, value);\r\n\t\t} else {\r\n\t\t\thelper.add(prop, singleRes);\r\n\t\t\tif (!options?.checkAll) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn helper.get();\r\n}\r\n\r\nexport function schema<T>(\r\n\tschemaStructure?: SchemaStructure<T>\r\n): SchemaBuilder<T> {\r\n\tconst schema: ValidatonSchema<T> = schemaStructure\r\n\t\t? parseSchemaStructure(schemaStructure)\r\n\t\t: {};\r\n\tconst builder: SchemaBuilder<T> = {\r\n\t\tset: (name: keyof T, ...callbacks: ValidationCallback<T>[]) => {\r\n\t\t\tschema[name as string] = callbacks;\r\n\t\t\treturn builder;\r\n\t\t},\r\n\t\tdefine: (...fields: SchemaFieldBuilderBase<T>[]) => {\r\n\t\t\tfields.forEach((field) => {\r\n\t\t\t\tconst { name, callbacks } = field.build();\r\n\t\t\t\tschema[name as string] = callbacks;\r\n\t\t\t});\r\n\t\t\treturn builder;\r\n\t\t},\r\n\t\tbuild: () => {\r\n\t\t\treturn schema;\r\n\t\t},\r\n\t};\r\n\treturn builder;\r\n}\r\n\r\nexport function field<T>(name: keyof T): SchemaFieldBuilder<T> {\r\n\tconst callbacks: ValidationCallback<T>[] = [];\r\n\tconst builder = {\r\n\t\tset: (...validators: ValidationCallback<T>[]) => {\r\n\t\t\tif (!validators) throw new Error(\"Callback not provided\");\r\n\t\t\tcallbacks.push(...validators);\r\n\t\t\treturn builder;\r\n\t\t},\r\n\r\n\t\tbuild: (): SchemaField<T> => {\r\n\t\t\treturn {\r\n\t\t\t\tname,\r\n\t\t\t\tcallbacks,\r\n\t\t\t};\r\n\t\t},\r\n\t};\r\n\treturn builder;\r\n}\r\n"],"sourceRoot":""}