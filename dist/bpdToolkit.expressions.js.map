{"version":3,"sources":["webpack://bpdToolkit.[name]/webpack/universalModuleDefinition","webpack://bpdToolkit.[name]/webpack/bootstrap","webpack://bpdToolkit.[name]/webpack/runtime/define property getters","webpack://bpdToolkit.[name]/webpack/runtime/hasOwnProperty shorthand","webpack://bpdToolkit.[name]/webpack/runtime/make namespace object","webpack://bpdToolkit.[name]/./src/expressions.ts"],"names":[],"mappings":"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","file":"bpdToolkit.expressions.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpdToolkit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpdToolkit\"] = factory();\n\telse\n\t\troot[\"bpdToolkit\"] = root[\"bpdToolkit\"] || {}, root[\"bpdToolkit\"][\"expressions\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export interface IValidationPattern {\r\n\texpr(...expressions: string[]): IValidationPattern;\r\n\tcheck(expression: string): IValidationPattern;\r\n\tofLength(min: number, max?: number): IValidationPattern;\r\n\twithCapital(count?: number): IValidationPattern;\r\n\twithLower(count?: number): IValidationPattern;\r\n\twithWhitespace(count?: number): IValidationPattern;\r\n\twithAnyOf(characters?: string): IValidationPattern;\r\n\twithNoneOf(characters: string): IValidationPattern;\r\n\twithDigits(count?: number): IValidationPattern;\r\n\tnoWhitespace(): IValidationPattern;\r\n\tdigitsOnly(): IValidationPattern;\r\n\twordOnly(): IValidationPattern;\r\n\tnoDigits(): IValidationPattern;\r\n}\r\n\r\nexport interface IExpressionPattern {\r\n\ttoExpression(flags?: string): RegExp;\r\n}\r\n\r\ninterface IMatchResult {\r\n\tresult: boolean;\r\n\tinput: string;\r\n\terror?: Error | string;\r\n\torigin: RegExpMatchArray | null;\r\n\ttime: number;\r\n\tpattern: RegExp | string | null;\r\n}\r\n\r\n/**\r\n * Creates expression like ([^expr]*[exp][^exp]*)\r\n * @param expression\r\n * @returns new expression following pattern\r\n */\r\nfunction createOccurencePattern(expression: string) {\r\n\treturn group(\r\n\t\tnotOneOf(expression),\r\n\t\t\"*\",\r\n\t\toneOf(expression),\r\n\t\tnotOneOf(expression),\r\n\t\t\"*\"\r\n\t);\r\n}\r\n\r\n/**\r\n * Creates expression like ^([^expr]*[expr][^expr]*){min, max}$\r\n * @param expression expression to check\r\n * @param min count min\r\n * @param max count max\r\n * @returns new expression following pattern\r\n */\r\nfunction createOccurenceExpression(\r\n\texpression: string,\r\n\tmin: number,\r\n\tmax?: number\r\n) {\r\n\treturn all(createOccurencePattern(expression), range(min, max));\r\n}\r\n\r\n/**\r\n * Perform matching of string to validation pattern.\r\n * Function calculates execution time and return it with result\r\n * @param {String} value input value\r\n * @param {IExpressionPattern} pattern validation pattern\r\n * @param {String} flags - optional - regExp flags\r\n * @returns {IMatchResult} Match result\r\n */\r\nexport function matches(\r\n\tvalue: string,\r\n\tpattern: string | RegExp,\r\n): IMatchResult {\r\n\tlet result: IMatchResult = {\r\n\t\tresult: false,\r\n\t\torigin: null,\r\n\t\tpattern: null,\r\n\t\tinput: value,\r\n\t\ttime: -1,\r\n\t};\r\n\tif (!value) {\r\n\t\treturn result;\r\n\t}\r\n\tconst t1 = performance.now();\r\n\ttry {\r\n\t\tconst matchResult = value.match(pattern);\r\n\t\tresult.pattern = pattern;\r\n\t\tresult.result = matchResult !== null;\r\n\t\tresult.origin = matchResult;\r\n\t} catch (e) {\r\n\t\tresult.error = e;\r\n\t} finally {\r\n\t\tresult.time = performance.now() - t1;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Merges expressions into string\r\n * @param {String[]} expressions expressions\r\n * @returns pattern\r\n */\r\nfunction expression(expressions: string[]): string {\r\n\treturn expressions.join(\"\");\r\n}\r\n\r\n/**\r\n * Creates pattern ^value$\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function all(...value: string[]): string {\r\n\treturn `^${expression(value)}$`;\r\n}\r\n\r\n/**\r\n * Creates pattern (value)\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function group(...value: string[]): string {\r\n\treturn `(${expression(value)})`;\r\n}\r\n\r\n/**\r\n * Creates pattern value|value|value...\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function or(...value: string[]): string {\r\n\treturn value.join(\"|\");\r\n}\r\n\r\n/**\r\n * Creates pattern [value]\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function oneOf(...value: string[]): string {\r\n\treturn `[${expression(value)}]`;\r\n}\r\n\r\n/**\r\n * Creates pattern [^value]\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function notOneOf(...value: string[]): string {\r\n\treturn `[^${expression(value)}]`;\r\n}\r\n\r\n/**\r\n * Creates pattern (?=value)\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function positiveLookahead(...value: string[]): string {\r\n\treturn group(\"?=\", ...value);\r\n}\r\n\r\n/**\r\n * Creates pattern (?!value)\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function negativeLookahead(...value: string[]): string {\r\n\treturn group(\"?!\", ...value);\r\n}\r\n\r\n/**\r\n * Creates range pattern {min, max}\r\n * When min === max then pattern is {min}\r\n * @param min range min\r\n * @param max range max\r\n * @returns pattern\r\n */\r\nexport function range(min: number, max?: number) {\r\n\treturn min === max ? `{${min}}` : `{${min},${max ?? \"\"}}`;\r\n}\r\n\r\n/**\r\n * Creates pattern value+\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function atLeastOne(...value: string[]) {\r\n\treturn `${expression(value)}+`;\r\n}\r\n/**\r\n * Creates pattern value*\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function noneOrMore(...value: string[]) {\r\n\treturn `${expression(value)}*`;\r\n}\r\n\r\n/**\r\n * Creates pattern value?\r\n * @param {String[]} value expressions\r\n * @returns pattern\r\n */\r\nexport function noneOrOne(...value: string[]) {\r\n\treturn `${expression(value)}?`;\r\n}\r\n\r\nexport const capitalLetters = \"A-Z\";\r\nexport const lowerLetters = \"a-z\";\r\nexport const digit = \"\\\\d\";\r\nexport const notDigit = \"\\\\D\";\r\nexport const whitespace = \"\\\\s\";\r\nexport const notWhitespace = \"\\\\S\";\r\nexport const word = \"\\\\w\";\r\nexport const notWord = \"\\\\W\";\r\nexport const any = \".\";\r\nexport const specialCharacters = \"\\\\!\\\\*\\\\_\\\\?\\\\+\\\\=\\\\^\\\\$-@%#&\";\r\n\r\n/**\r\n * Helper class that builds regex validation pattern for strings\r\n * Logic is based on positive lookahead pattern. Expression is created from set of such rules\r\n */\r\nexport default class ValidationPattern\r\n\timplements IValidationPattern, IExpressionPattern\r\n{\r\n\tprivate _list: string[];\r\n\tconstructor(init?: string) {\r\n\t\tthis._list = [];\r\n\t\tif (init) {\r\n\t\t\tthis._list.push(init);\r\n\t\t}\r\n\t}\r\n\r\n\texpr(...expressions: string[]): IValidationPattern {\r\n\t\tthis._list.push(...expressions);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string passes some condition\r\n\t * @param {String} expression - expression to check\r\n\t * @returns instance\r\n\t */\r\n\tcheck(expression: string): IValidationPattern {\r\n\t\treturn this.expr(positiveLookahead(expression));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates length of the string\r\n\t * If max is not provided then only minimum is checked\r\n\t * If min == max then string length shall equal exactly min\r\n\t * @param {Number} min - minimum number of occurences\r\n\t * @param {Number} max - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\tofLength(min: number, max?: number): IValidationPattern {\r\n\t\treturn this.check(all(`.${range(min, max)}`));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates whether string contains capital letters\r\n\t * @param {Number} count - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\twithCapital(count?: number): IValidationPattern {\r\n\t\treturn this.check(createOccurenceExpression(capitalLetters, 1, count));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates whether string contains lower cased letters\r\n\t * @param {Number} count - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\twithLower(count?: number): IValidationPattern {\r\n\t\treturn this.check(createOccurenceExpression(lowerLetters, 1, count));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates whether string contains whitespaces\r\n\t * @param {Number} count - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\twithWhitespace(count?: number): IValidationPattern {\r\n\t\treturn this.check(createOccurenceExpression(whitespace, 1, count));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string contain any of the characters\r\n\t * @param {String} characters - characters to check\r\n\t * @returns instance\r\n\t */\r\n\twithAnyOf(characters?: string): IValidationPattern {\r\n\t\tconst specialChars = characters ?? specialCharacters;\r\n\t\treturn this.check(createOccurenceExpression(specialChars, 1));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string does not contain characters\r\n\t * Pattern looks like: (?=^((?![characters]]).)*$)\r\n\t * @param characters - string containing characters that shall not be in input\r\n\t * @returns instance\r\n\t */\r\n\twithNoneOf(characters: string): IValidationPattern {\r\n\t\treturn this.check(\r\n\t\t\tall(group(negativeLookahead(oneOf(characters)), \".\"), \"*\")\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string contains digits\r\n\t * @param {Number} count - {optional} - maximum number of occurences\r\n\t * @returns instance\r\n\t */\r\n\twithDigits(count?: number): IValidationPattern {\r\n\t\treturn this.check(createOccurenceExpression(digit, 1, count));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string does not contain whitespaces\r\n\t * @returns instance\r\n\t */\r\n\tnoWhitespace(): IValidationPattern {\r\n\t\treturn this.check(all(notWhitespace, \"+\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Adds expression that validates whether string contains only digits\r\n\t * @returns instance\r\n\t */\r\n\tdigitsOnly(): IValidationPattern {\r\n\t\treturn this.check(all(digit, \"+\"));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates if string contains word only characters (a-zA-Z0-9_)\r\n\t * @returns instance\r\n\t */\r\n\twordOnly(): IValidationPattern {\r\n\t\treturn this.check(all(word, \"+\"));\r\n\t}\r\n\t/**\r\n\t * Adds expression that validates if string does not contain any digit\r\n\t * @returns instance\r\n\t */\r\n\tnoDigits(): IValidationPattern {\r\n\t\treturn this.check(all(notDigit, \"+\"));\r\n\t}\r\n\r\n\ttoString(): string {\r\n\t\treturn this._list.join(\"\");\r\n\t}\r\n\r\n\t/**\r\n\t * Creates regular expression from string representation of the instance\r\n\t * @param flags - regex flags\r\n\t * @returns {RegExp} regular exporession\r\n\t */\r\n\ttoExpression(flags?: string): RegExp {\r\n\t\treturn new RegExp(\"^\" + this.toString() + \".*$\", flags);\r\n\t}\r\n}\r\n"],"sourceRoot":""}